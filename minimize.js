'use strict';

const Shift = require('shift-ast/checked');

const { accessPath, cloneWithReplacement } = require('./util.js');
const { BlockStatement, Block } = require('shift-ast/checked');

function* shrink(node) {
  // note that this only knows how to shrink the kinds of tree generated by ./fuzz.js, not arbitrary ASTs
  // we search breadth-first, since removing outer nodes is more valuable
  const queue = [[]]; // list of paths, where a path is a sequence of property names
  while (queue.length > 0) {
    const path = queue.pop();
    const c = accessPath(node, path);
    if (c === null) { // === instead of == so that giving invalid paths will still error
      continue;
    }
    if (c === void 0) {
      console.log(JSON.stringify(node, null, 2));
      throw new Error('bad path: ' + JSON.stringify(path));
    }
    const replace = c => cloneWithReplacement(node, path, c);
    if (Array.isArray(c)) {
      for (let i = 0; i < c.length; ++i) {
        const copy = [...c];
        copy.splice(i, 1);
        yield replace(copy);
        queue.push(path.concat([i]));
      }
    } else {
      // TODO: derive this automatically from the AST spec
      switch (c.type) {
        case 'Module': {
          queue.push(path.concat(['directives']));
          queue.push(path.concat(['items']));
          break;
        }
        case 'Export': {
          if (!((c.declaration.type === 'ClassDeclaration' || c.declaration.type === 'FunctionDeclaration') && c.declaration.name == '*default*')) {
            yield replace(c.declaration);
          }
          queue.push(path.concat(['declaration']));
          break;
        }
        case 'ExportDefault': {
          if (c.body.type === 'ClassDeclaration' || c.body.type === 'FunctionDeclaration') {
            if (c.body.name !== '*default*') {
              // TODO other cases
              yield replace(c.body);
            }
          } else {
            yield replace(new Shift.ExpressionStatement({ expression: c.body }));
          }
          queue.push(path.concat(['body']));
          break;
        }
        case 'ClassDeclaration': {
          for (let element of c.elements) {
            yield replace(
              new Shift.FunctionDeclaration({
                name: c.name,
                isGenerator: false,
                isAsync: false,
                params: new Shift.FormalParameters({ items: [], rest: null }),
                body: element.method.body,
              })
            );
          }
          if (c.super != null) {
            yield replace(new Shift.ClassDeclaration({ name: c.name, super: null, elements: c.elements }));
          }
          queue.push(path.concat(['elements']));
          break;
        }
        case 'FunctionDeclaration': {
          // TODO this isn't legal; you have to know the declaration is not in an `export default`
          for (let statement of c.body.statements) {
            yield replace(statement);
          }
          queue.push(path.concat('body'));
          break;
        }
        case 'ClassElement': {
          queue.push(path.concat(['method']));
          break;
        }
        case 'Getter': {
          // todo shrink name
          queue.push(path.concat('name'));
          queue.push(path.concat('body'));
          break;
        }
        case 'Method': {
          if (!(c.name.type === 'StaticPropertyName' && c.name.value === 'constructor')) {
            queue.push(path.concat('name'));          
          }
          queue.push(path.concat('params'));
          queue.push(path.concat('body'));
          break;
        }
        case 'FunctionBody': {
          queue.push(path.concat('directives'));
          queue.push(path.concat('statements'));
          break;
        }
        case 'ExpressionStatement': {
          yield replace(new Shift.EmptyStatement({}));
          queue.push(path.concat(['expression']));
          break;
        }
        case 'DebuggerStatement': {
          yield replace(new Shift.EmptyStatement({}));
          break;
        }
        case 'DoWhileStatement': {
          yield replace(new Shift.EmptyStatement({}));
          yield replace(new Shift.WhileStatement({ test: c.test, body: c.body }));
          yield replace(new Shift.ExpressionStatement({ expression: c.test }));
          yield replace(c.body);
          queue.push(path.concat(['test']));
          queue.push(path.concat(['body']));
          break;
        }
        case 'WhileStatement': {
          yield replace(new Shift.EmptyStatement({}));
          yield replace(new Shift.ExpressionStatement({ expression: c.test }));
          yield replace(c.body);
          queue.push(path.concat(['test']));
          queue.push(path.concat(['body']));
          break;
        }
        case 'ForAwaitStatement':
        case 'ForOfStatement':
        case 'ForInStatement': {
          yield replace(new Shift.EmptyStatement({}));
          if (c.left.type === 'VariableDeclaration') {
            yield replace(new Shift.VariableDeclarationStatement({
              declaration: new Shift.VariableDeclaration({
                kind: c.left.kind,
                declarators: [new Shift.VariableDeclarator({
                  binding: c.left.declarators[0].binding,
                  init: c.right,
                })],
              })
            }));
          } else {            
            yield replace(new Shift.ExpressionStatement({ expression: new Shift.AssignmentExpression({ binding: c.left, expression: c.right }) }));
          }
          yield replace(new Shift.ExpressionStatement({ expression: c.right }));
          // TODO gotta check for no break/continue first
          yield replace(c.body);
          queue.push(path.concat('left'));
          queue.push(path.concat('right'));
          queue.push(path.concat('body'));
          break;
        }
        case 'TryCatchStatement': {
          yield replace(new Shift.BlockStatement({ block: c.body }));
          yield replace(new Shift.BlockStatement({ block: c.catchClause.body }));

          queue.push(path.concat(['body']));
          queue.push(path.concat(['catchClause', 'body']));
          break;
        }
        case 'TryFinallyStatement': {
          if (c.catchClause === null) {
            yield replace(new Shift.BlockStatement({ block: c.body }));
            yield replace(new Shift.BlockStatement({ block: c.finalizer }));

            queue.push(path.concat(['body']));
            queue.push(path.concat(['finalizer']));
          } else {
            yield replace(new Shift.TryCatchStatement({ body: c.body, catchClause: c.catchClause }));
            yield replace(new Shift.TryFinallyStatement({ body: c.body, catchClause: null, finalizer: c.finalizer }));
            yield replace(new Shift.BlockStatement({ block: c.body }));
            yield replace(new Shift.BlockStatement({ block: c.catchClause.body }));
            yield replace(new Shift.BlockStatement({ block: c.finalizer }));

            queue.push(path.concat(['body']));
            queue.push(path.concat(['catchClause', 'body']));
            queue.push(path.concat(['finalizer']));
          }
          break;
        }
        case 'BlockStatement': {
          yield replace(new Shift.EmptyStatement({}));
          if (c.block.statements.length === 1) {
            yield replace(c.block.statements[0]);
          }
          queue.push(path.concat(['block', 'statements']));
          break;
        }
        case 'Block': {
          queue.push(path.concat(['statements']));
          break;
        }
        case 'LabeledStatement': {
          yield replace(new Shift.EmptyStatement({}));
          // It would be nice if we could get rid of the label, but preserving validity is hard
          queue.push(path.concat(['body']));
          break;
        }
        case 'FunctionDeclaration': {
          queue.push(path.concat(['body', 'statements']));
          break;
        }
        case 'ForStatement': {
          yield replace(new Shift.EmptyStatement({}));
          if (c.init !== null) {
            if (c.init.type === 'VariableDeclaration') {
              yield replace(new Shift.VariableDeclarationStatement({ declaration: c.init }));
            } else {
              yield replace(new Shift.ExpressionStatement({ expression: c.init }));
            }
            yield replace(new Shift.ForStatement({ init: null, test: c.test, update: c.update, body: c.body }));
          }
          if (c.test !== null) {
            yield replace(new Shift.ExpressionStatement({ expression: c.test }));
            yield replace(new Shift.ForStatement({ init: c.init, test: null, update: c.update, body: c.body }));
          }
          if (c.update !== null) {
            yield replace(new Shift.ExpressionStatement({ expression: c.update }));
            yield replace(new Shift.ForStatement({ init: c.init, test: c.test, update: null, body: c.body }));
          }
          // TODO this requres first ensuring there are no unlabelled `break` or `continue` statements
          yield replace(c.body);
          queue.push(path.concat(['init']));
          queue.push(path.concat(['test']));
          queue.push(path.concat(['update']));
          queue.push(path.concat(['body']));
          break;
        }
        case 'IfStatement': {
          yield replace(c.consequent);
          yield replace(c.alternate);

          queue.push(path.concat(['consequent']));
          queue.push(path.concat(['alternate']));
          break;
        }
        case 'SwitchStatement': {
          yield replace(new Shift.EmptyStatement({}));
          yield replace(new Shift.ExpressionStatement({ expression: c.discriminant }));
          for (let _case of c.cases) {
            yield replace(new Shift.ExpressionStatement({ expression: _case.test }));
          }
          queue.push(path.concat(['discriminant']));
          queue.push(path.concat(['cases']));
          break;
        }
        case 'SwitchStatementWithDefault': {
          yield replace(new Shift.EmptyStatement({}));
          yield replace(new Shift.ExpressionStatement({ expression: c.discriminant }));
          let cases = [...c.preDefaultCases, ...c.postDefaultCases];
          yield replace(new SwitchStatement({ discriminant: c.discriminant, cases }));
          for (let _case of cases) {
            yield replace(new Shift.ExpressionStatement({ expression: _case.test }));
          }
          queue.push(path.concat(['discriminant']));
          queue.push(path.concat(['preDefaultCases']));
          queue.push(path.concat(['postDefaultCases']));
          break;
        }
        case 'SwitchCase': {
          queue.push(path.concat(['test']));
          queue.push(path.concat(['consequent']));
          break;
        }
        case 'ThrowStatement': {
          yield replace(new Shift.EmptyStatement({}));
          yield replace(new Shift.ExpressionStatement({ expression: c.expression }));
          queue.push(path.concat(['expression']));
          break;
        }
        case 'VariableDeclarationStatement': {
          yield replace(new Shift.EmptyStatement({}));
          let initialized = c.declaration.declarators.filter(d => d.init !== null);
          for (let declarator of initialized) {
            yield replace(new Shift.ExpressionStatement({ expression: declarator.init }));
          }
          queue.push(path.concat(['declaration']));
          break;
        }
        case 'VariableDeclaration': {
          if (c.declarators.length > 1) {
            for (let i = 0; i < c.declarators.length; ++i) {
              // we can't just add `.declarators` to the queue because the array-handling logic can produce empty arrays
              const copy = [...c.declarators];
              copy.splice(i, 1);
              yield replace(new Shift.VariableDeclaration({ kind: c.kind, declarators: copy }));
            }
          }
          if (c.kind === 'const') {
            yield replace(new Shift.VariableDeclaration({ kind: 'let', declarators: c.declarators }));
          }
          for (let i = 0; i < c.declarators.length; ++i) {
            queue.push(path.concat(['declarators', i]));
          }
          break;
        }
        case 'VariableDeclarator': {
          // TODO we need to know that this isn't a const declaration for this to be legal
          if (c.init !== null) {
            yield replace(new Shift.VariableDeclarator({ binding: c.binding, init: null }));
          }
          queue.push(path.concat(['binding']));
          if (c.init !== null) {
            queue.push(path.concat(['init']));
          }
          break;
        }
        case 'ObjectAssignmentTarget': {
          if (c.rest != null) {
            yield replace(c.rest);
            yield replace(new Shift.ObjectAssignmentTarget({ properties: c.properties, rest: null }));
            yield replace(new Shift.ObjectAssignmentTarget({ properties: c.properties.concat(c.rest), rest: null }));
          }
          queue.push(path.concat(['properties']));
          if (c.rest != null) {
            queue.push(path.concat(['rest']));
          }
          break;
        }
        case 'ArrayAssignmentTarget': {
          if (c.rest != null) {
            yield replace(c.rest);
            yield replace(new Shift.ArrayAssignmentTarget({ elements: c.elements, rest: null }));
            yield replace(new Shift.ArrayAssignmentTarget({ elements: c.elements.concat(c.rest), rest: null }));
          }
          queue.push(path.concat(['elements']));
          if (c.rest != null) {
            queue.push(path.concat(['rest']));
          }
          break;
        }
        case 'AssignmentTargetPropertyProperty': {
          if (c.name.type === 'ComputedPropertyName') {
            queue.push(path.concat(['name']));
          }
          queue.push(path.concat(['binding']));
          break;
        }
        case 'AssignmentTargetWithDefault': {
          yield replace(c.binding);
          queue.push(path.concat(['binding']));
          queue.push(path.concat(['init']));
          break;
        }
        case 'ComputedPropertyName': {
          yield replace(new Shift.StaticPropertyName({ value: '_' }));
          queue.push(path.concat(['expression']));
          break;
        }
        case 'StaticPropertyName': {
          if (c.value !== '_') {
            yield replace(new Shift.StaticPropertyName({ value: '_' }));
          }
          break;
        }
        case 'ComputedMemberAssignmentTarget': {
          yield replace(new Shift.StaticMemberAssignmentTarget({ object: c.object, property: '_' }));
          queue.push(path.concat(['object']));
          queue.push(path.concat(['expression']));
          break;
        }
        case 'StaticMemberAssignmentTarget': {
          yield replace(new Shift.AssignmentTargetIdentifier({ name: '_' }));
          if (c.property !== '_') {
            yield replace(new Shift.StaticMemberAssignmentTarget({ object: c.object, property: '_' }));
          }
          queue.push(path.concat(['object']));
          break;
        }
        case 'AssignmentTargetIdentifier': {
          if (c.name !== '_') {
            yield replace(new Shift.AssignmentTargetIdentifier({ name: '_' }));            
          }
          break;
        }
        case 'BindingWithDefault': {
          yield replace(c.binding);
          queue.push(path.concat(['binding']));
          queue.push(path.concat(['init']));
          break;
        }
        case 'ArrayExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          for (let element of c.elements) {
            if (element !== null && element.type !== 'SpreadElement') {
              yield replace(element);
            }
          }
          queue.push(path.concat(['elements']));
          break;
        }
        case 'AwaitExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          queue.push(path.concat(['expression']));
          break;
        }
        case 'ObjectExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          for (let element of c.properties) {
            // TODO handle other kinds: pull expressions out of computed property names, out spread properties, function expressions out of methods, etc
            if (element != null && element.type === 'DataProperty') {
              yield replace(element.expression);
            }
          }
          yield replace(new Shift.ArrayExpression({
            elements: c.properties
              .filter(p => p.type === 'SpreadProperty' || p.type === 'DataProperty')
              .map(p => p.type === 'SpreadProperty' ? new Shift.SpreadElement({ expression: p.expression }) : p.expression),
          }));

          queue.push(path.concat(['properties']));
          break;
        }
        case 'FunctionExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          let exprChildren = c.body.statements.filter(child => child.type === 'ExpressionStatement');
          for (let child of exprChildren) {
            yield replace(child.expression);
          }
          queue.push(path.concat(['params']));
          queue.push(path.concat(['body']));
          break;
        }
        case 'ArrowExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          if (!c.isAsync && c.body.type !== 'FunctionBody') {
            yield replace(c.body);
          }
          // TODO figure out if async keyword is necessary and omit if not
          queue.push(path.concat(['params']));
          queue.push(path.concat(['body']));
          break;
        }
        case 'ClassExpression': {
          // TODO dedup this with classdeclaration
          yield replace(new Shift.LiteralNullExpression({}));
          for (let element of c.elements) {
            yield replace(
              // todo get async/generator right
              new Shift.FunctionExpression({
                name: c.name,
                isGenerator: false,
                isAsync: false,
                params: new Shift.FormalParameters({ items: [], rest: null }),
                body: element.method.body,
              })
            );
          }
          if (c.super != null) {
            queue.push(path.concat(['super']));
            // TODO figure out if super() is called in the constructor and, if not, get rid of the `extends` clause:
            // yield replace(new Shift.ClassDeclaration({ super: null, elements: c.elements }));
          }
          queue.push(path.concat(['elements']));
          break;
        }
        case 'ConditionalExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          yield replace(c.test);
          yield replace(c.consequent);
          yield replace(c.alternate);
          queue.push(path.concat(['test']));
          queue.push(path.concat(['consequent']));
          queue.push(path.concat(['alternate']));
          break;
        }
        case 'LiteralRegExpExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          if (c.pattern !== '(?:)') {
            yield replace(new Shift.LiteralRegExpExpression({
              pattern: '(?:)',
              global: c.global,
              ignoreCase: c.ignoreCase,
              multiline: c.multiline,
              sticky: c.sticky,
              unicode: c.unicode,
            }));
          }
          break;
        }
        case 'CompoundAssignmentExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          yield replace(c.expression);
          yield replace(new Shift.AssignmentExpression({ binding: c.binding, expression: c.expression }));
          queue.push(path.concat(['binding']));
          queue.push(path.concat(['expression']));
          break;
        }
        case 'AssignmentExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          yield replace(c.expression);
          queue.push(path.concat(['binding']));
          queue.push(path.concat(['expression']));
          break;
        }
        case 'BinaryExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          yield replace(c.left);
          yield replace(c.right);
          queue.push(path.concat(['left']));
          queue.push(path.concat(['right']));
          break;
        }
        case 'NewExpression':
        case 'CallExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          if (c.callee.type !== 'Super')
          yield replace(c.callee);
          for (let arg of c.arguments) {
            if (arg.type !== 'SpreadElement') {
              yield replace(arg);
            }
          }
          queue.push(path.concat('arguments'));
          break;
        }
        case 'StaticMemberExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          yield replace(c.object);
          if (c.property !== '_') {
            yield replace(new Shift.StaticMemberExpression({ object: c.object, property: '_' }));
          }
          queue.push(path.concat(['object']));
          break;
        }
        case 'ComputedMemberExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          yield replace(c.object);
          yield replace(c.expression);
          queue.push(path.concat(['object']));
          queue.push(path.concat(['expression']));
          break;
        }
        case 'IdentifierExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          if (c.name !== '_') {
            yield replace(new Shift.IdentifierExpression({ name: '_' }));
          }
          break;
        }
        case 'ThisExpression':
        case 'NewTargetExpression':
        case 'LiteralInfinityExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          break;
        }
        case 'LiteralNumericExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          if (c.value !== 0) {
            yield replace(new Shift.LiteralNumericExpression({ value: 0 }));
          }
          break;
        }
        case 'LiteralBooleanExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          if (c.value !== true) {
            yield replace(new Shift.LiteralBooleanExpression({ value: true }));
          }
          break;
        }
        case 'LiteralStringExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          if (c.value !== '') {
            yield replace(new Shift.LiteralStringExpression({ value: '' }));
          }
          break;
        }
        case 'TemplateElement': {
          if (c.rawValue !== '') {
            yield replace(new Shift.TemplateElement({ rawValue: '' }));
          }
          break;
        }
        case 'TemplateExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          if (c.tag !== null) {
            yield replace(c.tag);
            yield replace(new Shift.TemplateExpression({ tag: null, elements: c.elements }));
          }
          for (let i = 1; i < c.elements.length; i += 2) {
            yield replace(c.elements[i]);
            const copy = [...c.elements];
            copy.splice(i - 1, 2);
            yield replace(new Shift.TemplateExpression({ tag: c.tag, elements: copy }));
          }
          for (let i = 0; i < c.elements.length; ++i) {
            queue.push(path.concat(['elements', i]));
          }
          break;
        }
        case 'UpdateExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          yield replace(c.operand);
          queue.push(path.concat('operand'));
          break;
        }
        case 'UnaryExpression': {
          yield replace(new Shift.LiteralNullExpression({}));
          yield replace(c.operand);
          queue.push(path.concat('operand'));
          break;
        }
        case 'SpreadElement': {
          yield replace(c.expression);
          queue.push(path.concat('expression'));
          break;
        }
        case 'SpreadProperty': {
          queue.push(path.concat('expression'));
          break;
        }
        case 'ShorthandProperty': {
          // we consider '{ a: a }' simpler than '{ a }', mostly because it is more amenable to further simplification
          yield replace(new Shift.DataProperty({
            name: new Shift.StaticPropertyName({ value: c.name.name }),
            expression: c.name,
          }));
          if (c.name.name !== '_') {
            yield replace(new Shift.ShorthandProperty({ name: new Shift.IdentifierExpression({ name: '_' }) }));
          }
          break;
        }
        case 'DataProperty': {
          queue.push(path.concat('name'));
          queue.push(path.concat('expression'));
          break;
        }
        case 'FormalParameters': {
          if (c.rest !== null) {
            yield replace(new Shift.FormalParameters({ items: c.items, rest: null }));
          }
          queue.push(path.concat(['items']));
          if (c.rest !== null) {
            queue.push(path.concat(['rest']));
          }
          break;
        }
        default:
          console.log(`don't know how to shrink ${c.type}`);
          // No known shrinkages
          // TODO: handle more cases?
          break;
      }
    }
  }
}

async function minimize(tree, isStillGood, log = () => {}) {
  if (!await isStillGood(tree)) {
    throw new Error('Input is already not good!');
  }

  let best = tree;

  let improved = false;
  search: while (true) {
    log('tick');
    for (let candidate of shrink(best)) {
      // TODO maybe run the validator & early error checker here?
      if (await isStillGood(candidate)) {
        log('improved!');
        best = candidate;
        improved = true;
        continue search;
      }
      log('tock');
    }
    break;
  }
  if (!improved) {
    log('could not improve');
  }

  return best;
}

module.exports = minimize;
